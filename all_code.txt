package kafka.common;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * РљР»Р°СЃСЃ Message РїСЂРµРґСЃС‚Р°РІР»СЏРµС‚ СЃРѕР±РѕР№ СЃС‚СЂСѓРєС‚СѓСЂСѓ СЃРѕРѕР±С‰РµРЅРёСЏ, РѕС‚РїСЂР°РІР»СЏРµРјРѕРіРѕ РІ Kafka.
 * Р РµР°Р»РёР·СѓРµС‚ РјРµС‚РѕРґС‹ СЃРµСЂРёР°Р»РёР·Р°С†РёРё Рё РґРµСЃРµСЂРёР°Р»РёР·Р°С†РёРё РІ JSON С„РѕСЂРјР°С‚.
 */
public class Message {

    // РџРѕР»Рµ РєР»СЋС‡Р° СЃРѕРѕР±С‰РµРЅРёСЏ
    private String key;

    // РџРѕР»Рµ Р·РЅР°С‡РµРЅРёСЏ СЃРѕРѕР±С‰РµРЅРёСЏ
    private String value;

    // РљРѕРЅСЃС‚СЂСѓРєС‚РѕСЂ РїРѕ СѓРјРѕР»С‡Р°РЅРёСЋ РґР»СЏ СЃРµСЂРёР°Р»РёР·Р°С†РёРё/РґРµСЃРµСЂРёР°Р»РёР·Р°С†РёРё
    public Message() {}

    // РљРѕРЅСЃС‚СЂСѓРєС‚РѕСЂ РґР»СЏ СЃРѕР·РґР°РЅРёСЏ РѕР±СЉРµРєС‚Р° Message СЃ Р·Р°РґР°РЅРЅС‹РјРё РєР»СЋС‡РѕРј Рё Р·РЅР°С‡РµРЅРёРµРј
    public Message(String key, String value) {
        this.key = key;
        this.value = value;
    }

    // Р“РµС‚С‚РµСЂС‹ Рё СЃРµС‚С‚РµСЂС‹ РґР»СЏ РїРѕР»РµР№ key Рё value

    /**
     * РџРѕР»СѓС‡РёС‚СЊ РєР»СЋС‡ СЃРѕРѕР±С‰РµРЅРёСЏ.
     * @return РєР»СЋС‡ СЃРѕРѕР±С‰РµРЅРёСЏ.
     */
    public String getKey() {
        return key;
    }

    /**
     * РЈСЃС‚Р°РЅРѕРІРёС‚СЊ РєР»СЋС‡ СЃРѕРѕР±С‰РµРЅРёСЏ.
     * @param key РєР»СЋС‡ СЃРѕРѕР±С‰РµРЅРёСЏ.
     */
    public void setKey(String key) {
        this.key = key;
    }

    /**
     * РџРѕР»СѓС‡РёС‚СЊ Р·РЅР°С‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёСЏ.
     * @return Р·РЅР°С‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёСЏ.
     */
    public String getValue() {
        return value;
    }

    /**
     * РЈСЃС‚Р°РЅРѕРІРёС‚СЊ Р·РЅР°С‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёСЏ.
     * @param value Р·РЅР°С‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёСЏ.
     */
    public void setValue(String value) {
        this.value = value;
    }

    /**
     * РЎРµСЂРёР°Р»РёР·СѓРµС‚ РѕР±СЉРµРєС‚ Message РІ JSON СЃС‚СЂРѕРєСѓ.
     * @return JSON РїСЂРµРґСЃС‚Р°РІР»РµРЅРёРµ РѕР±СЉРµРєС‚Р° Message.
     * @throws JsonProcessingException РµСЃР»Рё СЃРµСЂРёР°Р»РёР·Р°С†РёСЏ РЅРµ СѓРґР°Р»Р°СЃСЊ.
     */
    public String serialize() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.writeValueAsString(this);
    }

    /**
     * Р”РµСЃРµСЂРёР°Р»РёР·СѓРµС‚ JSON СЃС‚СЂРѕРєСѓ РІ РѕР±СЉРµРєС‚ Message.
     * @param json JSON СЃС‚СЂРѕРєР°.
     * @return РћР±СЉРµРєС‚ Message.
     * @throws JsonProcessingException РµСЃР»Рё РґРµСЃРµСЂРёР°Р»РёР·Р°С†РёСЏ РЅРµ СѓРґР°Р»Р°СЃСЊ.
     */
    public static Message deserialize(String json) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, Message.class);
    }

    /**
     * РџРµСЂРµРѕРїСЂРµРґРµР»С‘РЅРЅС‹Р№ РјРµС‚РѕРґ toString РґР»СЏ СѓРґРѕР±РЅРѕРіРѕ РѕС‚РѕР±СЂР°Р¶РµРЅРёСЏ РѕР±СЉРµРєС‚Р° Message РІ СЃС‚СЂРѕРєРѕРІРѕРј С„РѕСЂРјР°С‚Рµ.
     * @return СЃС‚СЂРѕРєРѕРІРѕРµ РїСЂРµРґСЃС‚Р°РІР»РµРЅРёРµ РѕР±СЉРµРєС‚Р° Message.
     * РџРѕРєР° РЅРµ РёСЃРїРѕР»СЊР·СѓСЋ, РЅРѕ РјРѕР¶РµС‚ РїРѕРЅР°РґРѕР±РёС‚СЊСЃСЏ РµСЃР»Рё РЅР°С‡РЅРµС‚ СЂР°Р·СЂР°СЃС‚Р°С‚СЊСЃСЏ РєРѕРґ
     */
    @Override
    public String toString() {
        return "Message {" +
               "key='" + key + '\'' +
               ", value='" + value + '\'' +
               '}';
    }

}
package kafka.consumer;

import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.common.serialization.StringDeserializer;

import java.time.Duration;
import java.util.Collections;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kafka.common.Message;

/**
 * РљР»Р°СЃСЃ ConsumerPull РѕС‚РІРµС‡Р°РµС‚ Р·Р° РїРѕР»СѓС‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёР№ РёР· Kafka С‚РѕРїРёРєР° СЃ РёСЃРїРѕР»СЊР·РѕРІР°РЅРёРµРј pull-РјРѕРґРµР»Рё.
 * Р РµР°Р»РёР·СѓРµС‚ СЂСѓС‡РЅРѕР№ РєРѕРјРјРёС‚ СЃРјРµС‰РµРЅРёР№ Рё РѕР±СЂР°Р±РѕС‚РєСѓ СЂРµС‚СЂР°РµРІ РїСЂРё РѕР±СЂР°Р±РѕС‚РєРµ СЃРѕРѕР±С‰РµРЅРёР№.
 */
public class ConsumerPull {

    // РђРґСЂРµСЃР° Р±СЂРѕРєРµСЂРѕРІ Kafka, Рє РєРѕС‚РѕСЂС‹Рј Р±СѓРґРµС‚ РїРѕРґРєР»СЋС‡Р°С‚СЊСЃСЏ Consumer
    private static final String BOOTSTRAP_SERVERS = "127.0.0.1:9094,127.0.0.1:9095,127.0.0.1:9096";

    // РЈРЅРёРєР°Р»СЊРЅС‹Р№ РёРґРµРЅС‚РёС„РёРєР°С‚РѕСЂ РіСЂСѓРїРїС‹ РєРѕРЅСЃСЊСЋРјРµСЂРѕРІ РґР»СЏ СЃРѕРІРјРµСЃС‚РЅРѕРіРѕ С‡С‚РµРЅРёСЏ С‚РѕРїРёРєР°
    private static final String GROUP_ID = "consumer-pull-group";

    // РЈРєР°Р·С‹РІР°РµС‚, СЃ РєР°РєРѕРіРѕ РјРµСЃС‚Р° РЅР°С‡РёРЅР°С‚СЊ С‡С‚РµРЅРёРµ, РµСЃР»Рё РЅРµ СЃСѓС‰РµСЃС‚РІСѓРµС‚ СЃРѕС…СЂР°РЅС‘РЅРЅРѕРіРѕ СЃРјРµС‰РµРЅРёСЏ
    private static final String OFFSET_RESET = "earliest";

    // РћС‚РєР»СЋС‡РµРЅРёРµ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРіРѕ РєРѕРјРјРёС‚Р° СЃРјРµС‰РµРЅРёР№
    private static final boolean AUTO_COMMIT = false;

    // РњРёРЅРёРјР°Р»СЊРЅС‹Р№ РѕР±СЉС‘Рј РґР°РЅРЅС‹С… (РІ Р±Р°Р№С‚Р°С…), РєРѕС‚РѕСЂС‹Р№ РґРѕР»Р¶РµРЅ Р±С‹С‚СЊ РґРѕСЃС‚СѓРїРµРЅ РґР»СЏ С‡С‚РµРЅРёСЏ Р·Р° РѕРґРёРЅ Р·Р°РїСЂРѕСЃ
    private static final int FETCH_MIN_BYTES = 1 * 1024 * 1024; // 1 MB

    // РњР°РєСЃРёРјР°Р»СЊРЅРѕРµ РІСЂРµРјСЏ РѕР¶РёРґР°РЅРёСЏ РЅРѕРІС‹С… РґР°РЅРЅС‹С… РґРѕ РІС‹РїРѕР»РЅРµРЅРёСЏ poll()
    private static final int FETCH_MAX_WAIT_MS = 5000; // 5 СЃРµРєСѓРЅРґ

    // РўР°Р№РјР°СѓС‚ РґР»СЏ РјРµС‚РѕРґР° poll, РєРѕС‚РѕСЂС‹Р№ РѕРїСЂРµРґРµР»СЏРµС‚, РєР°Рє РґРѕР»РіРѕ Р¶РґР°С‚СЊ РЅРѕРІС‹С… РґР°РЅРЅС‹С…
    private static final Duration POLL_TIMEOUT = Duration.ofMillis(5000);

    // РњР°РєСЃРёРјР°Р»СЊРЅРѕРµ РєРѕР»РёС‡РµСЃС‚РІРѕ РїРѕРїС‹С‚РѕРє РїРѕРІС‚РѕСЂРЅРѕР№ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ РїСЂРё РѕС€РёР±РєРµ
    private static final int MAX_RETRIES = 3;

    // Р—Р°РґРµСЂР¶РєР° РјРµР¶РґСѓ РїРѕРІС‚РѕСЂРЅС‹РјРё РїРѕРїС‹С‚РєР°РјРё РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ (РІ РјРёР»Р»РёСЃРµРєСѓРЅРґР°С…)
    private static final int RETRY_DELAY_MS = 1000;

    private static final Logger logger = LoggerFactory.getLogger(ConsumerPull.class);

    public static void main(String[] args) {
        // РќР°СЃС‚СЂРѕР№РєР° СЃРІРѕР№СЃС‚РІ Kafka Consumer
        Properties props = new Properties();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, GROUP_ID);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, OFFSET_RESET);
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, String.valueOf(AUTO_COMMIT));
        props.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, FETCH_MIN_BYTES);
        props.put(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, FETCH_MAX_WAIT_MS);

        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);

        // РџРѕРґРїРёСЃРєР° РЅР° Kafka С‚РѕРїРёРє
        consumer.subscribe(Collections.singletonList("my-topic"));

        try {
            while (true) {
                // РР·РІР»РµС‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёР№ РёР· С‚РѕРїРёРєР° СЃ РёСЃРїРѕР»СЊР·РѕРІР°РЅРёРµРј pull-РјРѕРґРµР»Рё
                ConsumerRecords<String, String> records = consumer.poll(POLL_TIMEOUT);

                // РС‚РµСЂР°С†РёСЏ РїРѕ РІСЃРµРј РїРѕР»СѓС‡РµРЅРЅС‹Рј СЃРѕРѕР±С‰РµРЅРёСЏРј
                for (ConsumerRecord<String, String> rec : records) {
                    int attempt = 0;
                    boolean success = false;

                    // Р РµС‚СЂР°Р№ Р»РѕРіРёРєР° РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёР№
                    while (attempt < MAX_RETRIES && !success) {
                        try {
                            // Р”РµСЃРµСЂРёР°Р»РёР·Р°С†РёСЏ СЃРѕРѕР±С‰РµРЅРёСЏ
                            Message message = Message.deserialize(rec.value());

                            // РЎС‹РјРёС‚РёСЂРѕРІР°С‚СЊ РѕС€РёР±РєСѓ РґР»СЏ С‚РµСЃС‚РёСЂРѕРІР°РЅРёСЏ СЂРµС‚СЂР°РµРІ
                            // РґР»СЏ СЌС‚РѕРіРѕ РЅРµРѕР±С…РѕРґРёРјРѕ Р·Р°СЃР»Р°С‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ СЃ Value = "test_retries"
                            if (rec.value().contains("test_retries")) {
                                throw new RuntimeException("РЎРёРјСѓР»СЏС†РёСЏ РѕС€РёР±РєРё РѕР±СЂР°Р±РѕС‚РєРё");
                            }

                            // Р›РѕРіРёСЂРѕРІР°РЅРёРµ РѕР±СЂР°Р±РѕС‚Р°РЅРЅРѕРіРѕ СЃРѕРѕР±С‰РµРЅРёСЏ
                            logger.info("Pull Consumer РїРѕР»СѓС‡РёР» СЃРѕРѕР±С‰РµРЅРёРµ: key = {}, value = {}, partition = {}, offset = {}",
                                    rec.key(), message.getValue(), rec.partition(), rec.offset());

                            

                            success = true; // Р•СЃР»Рё РѕР±СЂР°Р±РѕС‚РєР° СѓСЃРїРµС€РЅР°, Р·Р°РІРµСЂС€Р°РµРј С†РёРєР» СЂРµС‚СЂР°РµРІ
                        } catch (Exception e) {
                            attempt++;
                            logger.error("РћС€РёР±РєР° РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ (РїРѕРїС‹С‚РєР° {}/{}): {}", attempt, MAX_RETRIES, e.getMessage());

                            if (attempt >= MAX_RETRIES) {
                                // Р•СЃР»Рё РєРѕР»РёС‡РµСЃС‚РІРѕ РїРѕРїС‹С‚РѕРє РїСЂРµРІС‹С€Р°РµС‚ Р»РёРјРёС‚, СЃРѕРѕР±С‰РµРЅРёРµ РјРѕР¶РµС‚ Р±С‹С‚СЊ РѕС‚РїСЂР°РІР»РµРЅРѕ РІ DLQ
                                logger.error("РќРµ СѓРґР°Р»РѕСЃСЊ РѕР±СЂР°Р±РѕС‚Р°С‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ РїРѕСЃР»Рµ {} РїРѕРїС‹С‚РѕРє: key = {}, value = {}",
                                        MAX_RETRIES, rec.key(), rec.value());
                              
                            } else {
                                try {
                                    // Р—Р°РґРµСЂР¶РєР° РїРµСЂРµРґ СЃР»РµРґСѓСЋС‰РµР№ РїРѕРїС‹С‚РєРѕР№
                                    Thread.sleep(RETRY_DELAY_MS);
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                    break;
                                }
                            }
                        }
                    }
                }

                // Р СѓС‡РЅРѕР№ РєРѕРјРјРёС‚ СЃРјРµС‰РµРЅРёР№ РїРѕСЃР»Рµ СѓСЃРїРµС€РЅРѕР№ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёР№
                if (!records.isEmpty()) {
                    try {
                        consumer.commitSync();
                        logger.info("РЎРјРµС‰РµРЅРёСЏ СѓСЃРїРµС€РЅРѕ Р·Р°С„РёРєСЃРёСЂРѕРІР°РЅС‹.");
                    } catch (Exception e) {
                        logger.error("РћС€РёР±РєР° РєРѕРјРјРёС‚Р° СЃРјРµС‰РµРЅРёР№: " + e.getMessage());
                    }
                }
            }
        } finally {
            // Р—Р°РєСЂС‹С‚РёРµ РєРѕРЅСЃСЊСЋРјРµСЂР° РґР»СЏ РѕСЃРІРѕР±РѕР¶РґРµРЅРёСЏ СЂРµСЃСѓСЂСЃРѕРІ
            consumer.close();
        }
    }
}
package kafka.consumer;

import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.common.serialization.StringDeserializer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.Collections;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import kafka.common.Message;

/**
 * РљР»Р°СЃСЃ ConsumerPush СЌРјСѓР»РёСЂСѓРµС‚ push-РјРѕРґРµР»СЊ РґР»СЏ РїРѕР»СѓС‡РµРЅРёСЏ СЃРѕРѕР±С‰РµРЅРёР№ РёР· Kafka С‚РѕРїРёРєР°.
 * РСЃРїРѕР»СЊР·СѓРµС‚ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРёР№ РєРѕРјРјРёС‚ СЃРјРµС‰РµРЅРёР№ Рё РѕР±СЂР°Р±РѕС‚РєСѓ СЃРѕРѕР±С‰РµРЅРёР№ РІ РѕС‚РґРµР»СЊРЅРѕРј РїРѕС‚РѕРєРµ.
 * Р РµР°Р»РёР·СѓРµС‚ СЂРµС‚СЂР°Рё РїСЂРё РѕР±СЂР°Р±РѕС‚РєРµ СЃРѕРѕР±С‰РµРЅРёР№.
 */
public class ConsumerPush {

    // РђРґСЂРµСЃР° Р±СЂРѕРєРµСЂРѕРІ Kafka, Рє РєРѕС‚РѕСЂС‹Рј Р±СѓРґРµС‚ РїРѕРґРєР»СЋС‡Р°С‚СЊСЃСЏ Consumer
    private static final String BOOTSTRAP_SERVERS = "127.0.0.1:9094,127.0.0.1:9095,127.0.0.1:9096";

    // РЈРЅРёРєР°Р»СЊРЅС‹Р№ РёРґРµРЅС‚РёС„РёРєР°С‚РѕСЂ РіСЂСѓРїРїС‹ РєРѕРЅСЃСЊСЋРјРµСЂРѕРІ РґР»СЏ СЃРѕРІРјРµСЃС‚РЅРѕРіРѕ С‡С‚РµРЅРёСЏ С‚РѕРїРёРєР°
    private static final String GROUP_ID = "consumer-push-group";

    // РЈРєР°Р·С‹РІР°РµС‚, СЃ РєР°РєРѕРіРѕ РјРµСЃС‚Р° РЅР°С‡РёРЅР°С‚СЊ С‡С‚РµРЅРёРµ, РµСЃР»Рё РЅРµ СЃСѓС‰РµСЃС‚РІСѓРµС‚ СЃРѕС…СЂР°РЅС‘РЅРЅРѕРіРѕ СЃРјРµС‰РµРЅРёСЏ
    private static final String OFFSET_RESET = "earliest";

    // Р’РєР»СЋС‡РµРЅРёРµ Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєРѕРіРѕ РєРѕРјРјРёС‚Р° СЃРјРµС‰РµРЅРёР№
    private static final boolean AUTO_COMMIT = true;

    // РўР°Р№РјР°СѓС‚ РґР»СЏ РјРµС‚РѕРґР° poll, РєРѕС‚РѕСЂС‹Р№ РѕРїСЂРµРґРµР»СЏРµС‚, РєР°Рє РґРѕР»РіРѕ Р¶РґР°С‚СЊ РЅРѕРІС‹С… РґР°РЅРЅС‹С…
    private static final Duration POLL_TIMEOUT = Duration.ofMillis(100);

    // РњР°РєСЃРёРјР°Р»СЊРЅРѕРµ РєРѕР»РёС‡РµСЃС‚РІРѕ РїРѕРїС‹С‚РѕРє РїРѕРІС‚РѕСЂРЅРѕР№ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ РїСЂРё РѕС€РёР±РєРµ
    private static final int MAX_RETRIES = 3;

    // Р—Р°РґРµСЂР¶РєР° РјРµР¶РґСѓ РїРѕРІС‚РѕСЂРЅС‹РјРё РїРѕРїС‹С‚РєР°РјРё РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ (РІ РјРёР»Р»РёСЃРµРєСѓРЅРґР°С…)
    private static final int RETRY_DELAY_MS = 1000;

    private static final Logger logger = LoggerFactory.getLogger(ConsumerPush.class);

    public static void main(String[] args) {
        // РќР°СЃС‚СЂРѕР№РєР° СЃРІРѕР№СЃС‚РІ Kafka Consumer
        Properties props = new Properties();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);
        props.put(ConsumerConfig.GROUP_ID_CONFIG, GROUP_ID);
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, OFFSET_RESET);
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, String.valueOf(AUTO_COMMIT));

        KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props);
        consumer.subscribe(Collections.singletonList("my-topic"));

        // РЎРѕР·РґР°РЅРёРµ РїРѕС‚РѕРєР° РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёР№
        ExecutorService executor = Executors.newSingleThreadExecutor();

        executor.submit(() -> {
            try {
                while (true) {
                    // РР·РІР»РµС‡РµРЅРёРµ СЃРѕРѕР±С‰РµРЅРёР№ РёР· С‚РѕРїРёРєР° СЃ РёСЃРїРѕР»СЊР·РѕРІР°РЅРёРµРј pull-РјРѕРґРµР»Рё
                    ConsumerRecords<String, String> records = consumer.poll(POLL_TIMEOUT);

                    // РС‚РµСЂР°С†РёСЏ РїРѕ РІСЃРµРј РїРѕР»СѓС‡РµРЅРЅС‹Рј СЃРѕРѕР±С‰РµРЅРёСЏРј
                    for (ConsumerRecord<String, String> rec : records) {
                        int attempt = 0;
                        boolean success = false;

                        // Р РµС‚СЂР°Р№ Р»РѕРіРёРєР° РґР»СЏ РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёР№
                        while (attempt < MAX_RETRIES && !success) {
                            try {
                                // Р”РµСЃРµСЂРёР°Р»РёР·Р°С†РёСЏ СЃРѕРѕР±С‰РµРЅРёСЏ
                                Message message = Message.deserialize(rec.value());

                                // Р›РѕРіРёСЂРѕРІР°РЅРёРµ РѕР±СЂР°Р±РѕС‚Р°РЅРЅРѕРіРѕ СЃРѕРѕР±С‰РµРЅРёСЏ
                                logger.info("Push Consumer РїРѕР»СѓС‡РёР» СЃРѕРѕР±С‰РµРЅРёРµ: key = {}, value = {}, partition = {}, offset = {}",
                                        rec.key(), message.getValue(), rec.partition(), rec.offset());

                                success = true; // Р•СЃР»Рё РѕР±СЂР°Р±РѕС‚РєР° СѓСЃРїРµС€РЅР°, Р·Р°РІРµСЂС€Р°РµРј С†РёРєР» СЂРµС‚СЂР°РµРІ

                            } catch (Exception e) {
                                attempt++;
                                logger.error("РћС€РёР±РєР° РѕР±СЂР°Р±РѕС‚РєРё СЃРѕРѕР±С‰РµРЅРёСЏ (РїРѕРїС‹С‚РєР° {}/{}): {}", attempt, MAX_RETRIES, e.getMessage());

                                if (attempt >= MAX_RETRIES) {
                                    // Р•СЃР»Рё РєРѕР»РёС‡РµСЃС‚РІРѕ РїРѕРїС‹С‚РѕРє РїСЂРµРІС‹С€Р°РµС‚ Р»РёРјРёС‚, СЃРѕРѕР±С‰РµРЅРёРµ РјРѕР¶РµС‚ Р±С‹С‚СЊ РѕС‚РїСЂР°РІР»РµРЅРѕ РІ DLQ
                                    logger.error("РќРµ СѓРґР°Р»РѕСЃСЊ РѕР±СЂР°Р±РѕС‚Р°С‚СЊ СЃРѕРѕР±С‰РµРЅРёРµ РїРѕСЃР»Рµ {} РїРѕРїС‹С‚РѕРє: key = {}, value = {}",
                                            MAX_RETRIES, rec.key(), rec.value());
                                 
                                } else {
                                    try {
                                        // Р—Р°РґРµСЂР¶РєР° РїРµСЂРµРґ СЃР»РµРґСѓСЋС‰РµР№ РїРѕРїС‹С‚РєРѕР№
                                        Thread.sleep(RETRY_DELAY_MS);
                                    } catch (InterruptedException ie) {
                                        Thread.currentThread().interrupt();
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } finally {
                // Р—Р°РєСЂС‹С‚РёРµ РєРѕРЅСЃСЊСЋРјРµСЂР° РґР»СЏ РѕСЃРІРѕР±РѕР¶РґРµРЅРёСЏ СЂРµСЃСѓСЂСЃРѕРІ
                consumer.close();
            }
        });
    }
}
package kafka.producer;

import com.github.javafaker.Faker;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.Properties;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import kafka.common.Message;

/**
 * РљР»Р°СЃСЃ ProducerApp РѕС‚РІРµС‡Р°РµС‚ Р·Р° Р°РІС‚РѕРјР°С‚РёС‡РµСЃРєСѓСЋ РѕС‚РїСЂР°РІРєСѓ СЃРѕРѕР±С‰РµРЅРёР№ РІ Kafka С‚РѕРїРёРє.
 * Р РµР°Р»РёР·СѓРµС‚ РіРµРЅРµСЂР°С†РёСЋ СЃРѕРѕР±С‰РµРЅРёР№ СЃ РЅР°СЃС‚СЂР°РёРІР°РµРјРѕР№ СЃРєРѕСЂРѕСЃС‚СЊСЋ.
 */
public class ProducerApp {

    // РђРґСЂРµСЃР° Р±СЂРѕРєРµСЂРѕРІ Kafka, Рє РєРѕС‚РѕСЂС‹Рј Р±СѓРґРµС‚ РїРѕРґРєР»СЋС‡Р°С‚СЊСЃСЏ Producer
    private static final String BOOTSTRAP_SERVERS = "127.0.0.1:9094,127.0.0.1:9095,127.0.0.1:9096";

    // Р“Р°СЂР°РЅС‚РёСЏ РґРѕСЃС‚Р°РІРєРё СЃРѕРѕР±С‰РµРЅРёР№ At Least Once
    private static final String ACKS = "all";

    // РњР°РєСЃРёРјР°Р»СЊРЅРѕРµ РєРѕР»РёС‡РµСЃС‚РІРѕ СЂРµС‚СЂР°РµРІ РїСЂРё СЃР±РѕСЏС…
    private static final int RETRIES = 3;

    // Р’РєР»СЋС‡РµРЅРёРµ РёРґРµРјРїРѕС‚РµРЅС‚РЅРѕСЃС‚Рё РґР»СЏ РїСЂРµРґРѕС‚РІСЂР°С‰РµРЅРёСЏ РґСѓР±Р»РёСЂРѕРІР°РЅРёСЏ СЃРѕРѕР±С‰РµРЅРёР№
    private static final boolean IDEMPOTENCE = true;

    // Р—Р°РґРµСЂР¶РєР° РјРµР¶РґСѓ РїРѕРІС‚РѕСЂРЅС‹РјРё РїРѕРїС‹С‚РєР°РјРё РѕС‚РїСЂР°РІРєРё СЃРѕРѕР±С‰РµРЅРёР№ (РІ РјРёР»Р»РёСЃРµРєСѓРЅРґР°С…)
    private static final int RETRY_BACKOFF_MS = 1000;

    // РўР°Р№РјР°СѓС‚ РґРѕСЃС‚Р°РІРєРё СЃРѕРѕР±С‰РµРЅРёСЏ (РІ РјРёР»Р»РёСЃРµРєСѓРЅРґР°С…)
    private static final int DELIVERY_TIMEOUT_MS = 120000;

    // РљРѕР»РёС‡РµСЃС‚РІРѕ СЃРѕРѕР±С‰РµРЅРёР№, РѕС‚РїСЂР°РІР»СЏРµРјС‹С… РІ СЃРµРєСѓРЅРґСѓ
    private static final int MESSAGES_PER_SECOND = 3;

    private static final Logger logger = LoggerFactory.getLogger(ProducerApp.class);

    public static void main(String[] args) {
        // РќР°СЃС‚СЂРѕР№РєР° СЃРІРѕР№СЃС‚РІ Kafka Producer
        Properties props = new Properties();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        props.put(ProducerConfig.ACKS_CONFIG, ACKS);
        props.put(ProducerConfig.RETRIES_CONFIG, RETRIES);
        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, String.valueOf(IDEMPOTENCE));
        props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, RETRY_BACKOFF_MS);
        props.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG, DELIVERY_TIMEOUT_MS);

        KafkaProducer<String, String> producer = new KafkaProducer<>(props);

        String topic = "my-topic";
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        AtomicInteger messageCounter = new AtomicInteger(1);

        Faker faker = new Faker();

        Runnable messageTask = () -> {
            String key = "key-" + messageCounter.getAndIncrement();

            // Р“РµРЅРµСЂР°С†РёСЏ С„РµР№РєРѕРІС‹С… РґР°РЅРЅС‹С…
            String name = faker.name().fullName(); // РРјСЏ
            String address = faker.address().fullAddress(); // РђРґСЂРµСЃ
            String company = faker.company().name(); // РќР°Р·РІР°РЅРёРµ РєРѕРјРїР°РЅРёРё
            String phoneNumber = faker.phoneNumber().phoneNumber(); // РўРµР»РµС„РѕРЅ
            String value = String.format("Name: %s, Address: %s, Company: %s, Phone: %s", name, address, company, phoneNumber);

            Message message = new Message(key, value);
            String serializedMessage;
            try {
                serializedMessage = message.serialize();
            } catch (JsonProcessingException e) {
                logger.error("РћС€РёР±РєР° СЃРµСЂРёР°Р»РёР·Р°С†РёРё СЃРѕРѕР±С‰РµРЅРёСЏ: {}", e.getMessage());
                return;
            }

            ProducerRecord<String, String> rec = new ProducerRecord<>(topic, key, serializedMessage);
            producer.send(rec, (metadata, exception) -> {
                if (exception != null) {
                    logger.error("РћС€РёР±РєР° РїСЂРё РѕС‚РїСЂР°РІРєРµ СЃРѕРѕР±С‰РµРЅРёСЏ: {}", exception.getMessage());
                } else {
                    logger.info("РћС‚РїСЂР°РІР»РµРЅРѕ СЃРѕРѕР±С‰РµРЅРёРµ: key = {}, value = {}, partition = {}, offset = {}",
                        rec.key(), rec.value(), metadata.partition(), metadata.offset());
                }
            });
        };

        // Р—Р°РїСѓСЃРє РіРµРЅРµСЂР°С†РёРё СЃРѕРѕР±С‰РµРЅРёР№ СЃ Р·Р°РґР°РЅРЅРѕР№ СЃРєРѕСЂРѕСЃС‚СЊСЋ
        scheduler.scheduleAtFixedRate(messageTask, 0, 1000 / MESSAGES_PER_SECOND, TimeUnit.MILLISECONDS);

        // Р”РѕР±Р°РІР»СЏРµРј РѕР±СЂР°Р±РѕС‚С‡РёРє Р·Р°РІРµСЂС€РµРЅРёСЏ РґР»СЏ РєРѕСЂСЂРµРєС‚РЅРѕРіРѕ Р·Р°РєСЂС‹С‚РёСЏ РїСЂРѕРґСЋСЃРµСЂР°
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("Р—Р°РІРµСЂС€РµРЅРёРµ СЂР°Р±РѕС‚С‹...");
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                    logger.error("Р—Р°РґР°С‡Рё Р·Р°РІРµСЂС€РµРЅРёСЏ РЅРµ СѓСЃРїРµР»Рё РІС‹РїРѕР»РЅРёС‚СЊСЃСЏ.");
                }
            } catch (InterruptedException e) {
                // РџРѕРІС‚РѕСЂРЅРѕ РїСЂРµСЂС‹РІР°РµРј С‚РµРєСѓС‰РёР№ РїРѕС‚РѕРє
                Thread.currentThread().interrupt();
                logger.error("РћС€РёР±РєР° РїСЂРё Р·Р°РІРµСЂС€РµРЅРёРё: {}", e.getMessage());
            }
            producer.close();
        }));
    }
}
